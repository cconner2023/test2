<project_specification>
  <project_name>Project Refine</project_name>

  <overview>
    Project Refine is a medical triage decision support PWA used by a clinical team to expedite triage workflows. The application is 98% complete with full functionality in place. This specification covers the final 2% — fixing broken back navigation, consolidating gesture and animation libraries into unified patterns, and cleaning up the codebase for long-term maintainability. No existing UI, features, functionality, or data structures should be changed.
  </overview>

  <constraints>
    <constraint>DO NOT change any existing UI, visual design, or user-facing behavior</constraint>
    <constraint>DO NOT modify data structures, database schema, or data flow</constraint>
    <constraint>DO NOT change application features or functionality</constraint>
    <constraint>DO NOT add new dependencies — consolidate to fewer libraries</constraint>
    <constraint>ALL gestures, animations, and navigation must behave identically after refactoring</constraint>
    <constraint>Favor computation over memoization — prefer computing values when needed rather than caching in memory</constraint>
    <constraint>Eliminate all duplicated logic — shared utilities for anything used in more than one place</constraint>
    <constraint>Minimize prop drilling — reduce excessive prop passing where possible</constraint>
    <constraint>Code must be pattern-consistent so any team member can follow the same conventions everywhere</constraint>
    <constraint> do not commit to git </constraint>
  </constraints>

  <technology_stack>
    <frontend>
      <framework>React 19.2.0 with TypeScript ~5.9.3</framework>
      <bundler>Vite 7.2.4</bundler>
      <styling>Tailwind CSS 4.1.18</styling>
      <animations>@react-spring/web 10.0.3 (PRIMARY — consolidate all animations here)</animations>
      <gestures>@use-gesture/react 10.3.1 (PRIMARY — consolidate all gesture handling here)</gestures>
      <icons>lucide-react 0.562.0</icons>
      <pwa>vite-plugin-pwa 1.2.0</pwa>
    </frontend>
    <libraries_to_remove>
      <library>motion (^12.23.26) — completely unused, remove from package.json</library>
      <library>@formkit/auto-animate (^0.9.0) — replace 3 usages with react-spring useTrail, then remove</library>
    </libraries_to_remove>
    <communication>
      <api>N/A — PWA with local data, no backend API changes</api>
    </communication>
  </technology_stack>

  <feature_count>33</feature_count>

  <codebase_architecture>
    <components_directory>src/Components/ (20 components)</components_directory>
    <hooks_directory>src/Hooks/ (13 custom hooks, ~2,800 lines total)</hooks_directory>
    <utilities_directory>src/Utilities/ (GestureUtils.ts, AnimationConfig.ts, ColorUtilities.ts)</utilities_directory>
    <types_directory>src/Types/ (CatTypes.ts, AlgorithmTypes.ts, NavTopTypes.ts)</types_directory>
    <data_directory>src/Data/ (CatData.ts, Algorithms.ts, MedData.ts, Release.ts)</data_directory>
    <entry_point>src/App.tsx (687 lines — root component)</entry_point>
  </codebase_architecture>

  <core_features>
    <back_navigation_fixes>
      - Fix handleBackClick missing return statement after Priority 2 (guideline clearing) in useNavigation.ts — currently execution falls through unpredictably when both guideline and symptom are selected
      - Fix swipe-back viewDepth condition in useSwipeNavigation — viewDepth is set to 0 when not in Column B, disabling the gesture handler on navigation panels entirely
      - Unify cross-column swipe (App.tsx level) and within-column carousel swipe (ColumnA.tsx level) so they communicate properly rather than operating as two disconnected systems
      - Fix onSwipeBack timing in useColumnCarousel — currently called inside onRest (after spring animation completes) which causes visual/state sync issues between carousel position and navigation state
      - Verify NavTop back button renders and fires correctly on all applicable views including when drawers are open/closed and across mobile/desktop
      - Test all back navigation paths end-to-end on both mobile and desktop — category to main, symptom to category, guideline to symptom, Column B to Column A, and carousel panel to panel
    </back_navigation_fixes>

    <gesture_consolidation>
      - Unify all 4 useDrag implementations (useSwipeNavigation, useColumnCarousel, BaseDrawer, Settings SwipeableNoteItem) to follow one consistent pattern — same structure, same config approach, same threshold referencing
      - Consolidate all gesture configuration values through GestureUtils.ts constants — no more inline threshold values (80px, 0.3 velocity, 0.5 velocity, 60px, etc.) scattered across individual files
      - Refactor BaseDrawer mobile drag-to-close from manual requestAnimationFrame tweening to react-spring useSpring — eliminate the custom cubic ease-out rAF loop (lines 112-145)
      - Refactor Settings.tsx SwipeableNoteItem swipe gesture to use unified drag pattern and reference GestureUtils constants for action widths and overshoot dampening
      - Refactor useSwipeNavigation to align with unified gesture pattern while preserving its cross-column swipe-back detection behavior
      - Refactor useColumnCarousel drag handler to align with unified gesture pattern while preserving carousel physics (edge resistance, velocity-based fling, panel snapping)
      - Verify all gesture behaviors are visually and functionally identical after consolidation — same thresholds, same physics feel, same edge cases
    </gesture_consolidation>

    <animation_consolidation>
      - Remove motion package entirely from package.json — zero imports exist in the codebase, it is dead weight
      - Replace @formkit/auto-animate usage in CategoryList.tsx (useAppAnimate for list item mount/unmount) with react-spring useTrail for sequential item appearance
      - Replace @formkit/auto-animate usage in App.tsx (useAppAnimate on contentRef for child DOM transitions) with react-spring animation approach
      - Remove AnimationConfig.ts utility file and @formkit/auto-animate dependency from package.json after all usages are migrated
      - Verify all animations are visually identical after consolidation — same timing feel, same entrance/exit behavior, same user experience
    </animation_consolidation>

    <usenavigation_cleanup>
      - Deduplicate similar state-setting callbacks — closeMenu, setShowNoteImport, setShowSettings, setShowMedications, setShowSymptomInfo, setShowWriteNote all follow the same pattern of toggling a boolean and optionally closing other drawers
      - Move CLOSE_ALL_DRAWERS and other constants outside the hook to module scope so they are not recreated on every render
      - Clean up stateRef usage patterns — ensure stateRef is used consistently and only where truly necessary to avoid stale closures, not as a general pattern throughout
      - Verify all navigation flows work identically after cleanup — menu open/close, drawer open/close, category/symptom/guideline selection, mobile/desktop layout switching
    </usenavigation_cleanup>

    <note_hook_deduplication>
      - Extract bitmaskToIndices function (duplicated 3 times across useNoteImport.ts, useNoteRestore.ts, and potentially useNoteCapture.ts) into a shared utility file (e.g., src/Utilities/NoteUtils.ts or src/Utilities/EncodingUtils.ts)
      - Consolidate barcode parsing logic — useNoteImport.ts parseBarcode and useNoteRestore.ts parseEncodedText contain nearly identical prefix-based parsing logic that should live in one shared utility
      - Consolidate algorithm and decision-making content formatters — useNoteCapture.ts getAlgorithmContent/getDecisionMakingContent and useNoteImport.ts generateAlgorithmContent/generateDecisionMakingContent are near-identical and should be shared formatters
      - Verify note capture, import, restore, and share all function identically after deduplication — test barcode generation, scanning, parsing, and note rendering end-to-end
    </note_hook_deduplication>

    <general_hook_cleanup>
      - Extract useNoteShare.ts canvas helper functions (roundRect, generateShareCanvas, canvasToBlob) to module-level or a separate canvasUtils.ts utility file — they have no dependency on hook state and should not be recreated per render
      - Clean up useSearch.ts — move typePriority object to module-level constant, clean up search index construction
      - Review useCallback and useMemo dependencies across all hooks — remove unnecessary memoization (favor computation over memory), fix any missing or incorrect dependency arrays
      - Verify no regressions across all hook functionality after cleanup
    </general_hook_cleanup>

    <final_verification>
      - All UI is visually unchanged — every screen, every component, every animation looks exactly the same as before
      - All features function identically — triage workflows, algorithm navigation, note capture/import/share, search, settings, PWA behavior all work the same
      - Mobile and desktop responsive behavior is preserved — grid layouts, breakpoint switching, touch vs pointer interactions, drawer behavior all unchanged
    </final_verification>
  </core_features>

  <known_bugs>
    <bug location="useNavigation.ts line ~240">
      handleBackClick Priority 2 (selectedGuideline) does not return after clearing guideline. When both guideline and symptom are selected, state update behavior becomes unpredictable due to React batching.
    </bug>
    <bug location="useSwipeNavigation.ts + App.tsx lines 109-115">
      viewDepth is set to 0 when isMobileColumnB is false, which disables the useDrag gesture entirely via the enabled: enabled AND viewDepth > 0 condition. Swipe-back never fires on Column A panels.
    </bug>
    <bug location="useColumnCarousel.ts lines 130-134">
      onSwipeBack is called inside the spring onRest callback, creating a timing gap where the carousel animation has visually completed but navigation state hasn't updated yet, causing position/state desync.
    </bug>
    <bug location="App.tsx lines 505-506">
      Swipe touch handlers are ONLY attached when isMobile AND isMobileColumnB. No cross-column swipe detection exists for swiping from Column A, and the two gesture systems (app-level and carousel-level) operate independently.
    </bug>
  </known_bugs>

  <duplicated_code_inventory>
    <duplication>
      <function>bitmaskToIndices</function>
      <locations>useNoteImport.ts, useNoteRestore.ts (line ~15 in each)</locations>
      <resolution>Extract to shared utility (e.g., src/Utilities/EncodingUtils.ts)</resolution>
    </duplication>
    <duplication>
      <function>Barcode parsing (parseBarcode / parseEncodedText)</function>
      <locations>useNoteImport.ts, useNoteRestore.ts</locations>
      <resolution>Consolidate into single shared parsing utility</resolution>
    </duplication>
    <duplication>
      <function>Algorithm content formatting (getAlgorithmContent / generateAlgorithmContent)</function>
      <locations>useNoteCapture.ts, useNoteImport.ts</locations>
      <resolution>Extract to shared formatter utility</resolution>
    </duplication>
    <duplication>
      <function>Decision-making content formatting (getDecisionMakingContent / generateDecisionMakingContent)</function>
      <locations>useNoteCapture.ts, useNoteImport.ts</locations>
      <resolution>Extract to shared formatter utility</resolution>
    </duplication>
    <duplication>
      <function>State-toggling callbacks (closeMenu, setShow* handlers)</function>
      <locations>useNavigation.ts (multiple locations)</locations>
      <resolution>Deduplicate into a generic drawer/overlay state management pattern</resolution>
    </duplication>
  </duplicated_code_inventory>

  <gesture_system_architecture>
    <current_state>
      4 independent useDrag implementations with inline configs:
      - useSwipeNavigation.ts: horizontal cross-column swipe-back
      - useColumnCarousel.ts: horizontal carousel panel dragging with spring physics
      - BaseDrawer.tsx: vertical drawer drag-to-close with manual rAF animation
      - Settings.tsx: horizontal swipe-to-reveal-actions on note items
    </current_state>
    <target_state>
      All useDrag implementations follow one unified pattern:
      - All reference GestureUtils.ts for thresholds, velocities, and dampening values
      - All use react-spring for animation (no manual rAF)
      - All follow the same structural pattern for drag handlers (guard → compute → animate → callback)
      - GestureUtils.ts remains the single source of truth for all gesture constants
    </target_state>
    <existing_constants>
      GestureUtils.ts already defines:
      - GESTURE_THRESHOLDS: DIRECTION_LOCK (8px), FLING_VELOCITY (0.3), DRAWER_FLING_VELOCITY (0.5), SWIPE_BACK_THRESHOLD (80px), OVERSHOOT_DAMPENING (0.4), PAGE_DRAG_DAMPENING (0.85), EDGE_RESISTANCE (0.25), MIN_DRAG_FOR_VELOCITY (50px), PAGE_NAV_FRACTION (0.2)
      - SPRING_CONFIGS: snap, fling, page, stiff
      - Helpers: dampedOffset(), clamp(), parallaxTransform(), carouselPositions()
    </existing_constants>
  </gesture_system_architecture>

  <animation_system_architecture>
    <target_primary_library>@react-spring/web</target_primary_library>
    <libraries_to_remove>motion, @formkit/auto-animate</libraries_to_remove>
    <css_animations_to_keep>
      19 CSS keyframe animations in App.css — these are lightweight, performant, and working correctly. Keep as-is unless a specific consolidation opportunity arises.
    </css_animations_to_keep>
    <tailwind_transitions_to_keep>
      Tailwind transition-* and duration-* classes across components — these are standard CSS transitions and work well. Keep as-is.
    </tailwind_transitions_to_keep>
    <spring_configs>
      Centralized in GestureUtils.ts SPRING_CONFIGS:
      - snap: { tension: 300, friction: 30 }
      - fling: { tension: 200, friction: 25 }
      - page: { tension: 280, friction: 26 }
      - stiff: { tension: 400, friction: 35 }
      Additional in NavTop.tsx:
      - container: { tension: 220, friction: 26 }
      - menu items: { tension: 300, friction: 28 }
    </spring_configs>
  </animation_system_architecture>

  <code_quality_principles>
    <principle>Team readability — a new team member should be able to follow any gesture, animation, or navigation flow by recognizing the same pattern used everywhere</principle>
    <principle>Zero duplication — any logic used in more than one place must be extracted to a shared utility</principle>
    <principle>Minimal prop drilling — reduce excessive prop passing; prefer patterns that avoid threading props through multiple component layers</principle>
    <principle>Computation over memory — favor computing values when needed rather than caching with useMemo/useCallback; leverage React 19 compiler optimizations</principle>
    <principle>Single source of truth — GestureUtils.ts for all gesture constants, SPRING_CONFIGS for all spring physics, shared utilities for all formatting/parsing</principle>
    <principle>Module-level utilities — pure helper functions with no state dependencies should be at module level, not recreated inside hooks</principle>
  </code_quality_principles>

  <implementation_steps>
    <step number="1">
      <title>Fix Back Navigation Bugs</title>
      <tasks>
        - Add missing return statement in handleBackClick Priority 2
        - Fix viewDepth condition so swipe-back works on Column A panels
        - Unify cross-column and carousel swipe communication
        - Fix onSwipeBack timing (move out of onRest or sync state before animation)
        - Verify NavTop back button on all views
        - Test all back navigation paths mobile + desktop
      </tasks>
    </step>
    <step number="2">
      <title>Consolidate Gesture System</title>
      <tasks>
        - Define unified useDrag pattern (guard → compute → animate → callback)
        - Ensure all 4 useDrag implementations reference GestureUtils constants
        - Refactor BaseDrawer from rAF to useSpring
        - Refactor Settings SwipeableNoteItem to unified pattern
        - Align useSwipeNavigation and useColumnCarousel with unified pattern
        - Verify all gesture behaviors unchanged
      </tasks>
    </step>
    <step number="3">
      <title>Consolidate Animation Libraries</title>
      <tasks>
        - Remove motion package
        - Replace auto-animate in CategoryList with react-spring useTrail
        - Replace auto-animate in App.tsx with react-spring
        - Remove AnimationConfig.ts and auto-animate dependency
        - Verify all animations visually identical
      </tasks>
    </step>
    <step number="4">
      <title>Deduplicate Note Hooks</title>
      <tasks>
        - Extract bitmaskToIndices to shared utility
        - Consolidate barcode parsing into shared utility
        - Consolidate algorithm/decision-making formatters
        - Verify all note workflows function identically
      </tasks>
    </step>
    <step number="5">
      <title>Clean Up Hooks and Utilities</title>
      <tasks>
        - Deduplicate useNavigation callbacks and move constants to module scope
        - Extract useNoteShare canvas helpers to module level
        - Clean up useSearch constants
        - Remove unnecessary memoization (favor computation)
        - Review all dependency arrays
      </tasks>
    </step>
    <step number="6">
      <title>Final Verification</title>
      <tasks>
        - Visual regression check — all screens unchanged
        - Functional check — all features work identically
        - Responsive check — mobile and desktop behavior preserved
        - Gesture check — all touch interactions feel the same
        - Animation check — all transitions look the same
      </tasks>
    </step>
  </implementation_steps>

  <success_criteria>
    <functionality>
      All existing features work identically — triage workflows, algorithm navigation, note capture/import/restore/share, search, settings, drawers, PWA install/update. Back navigation works correctly on all paths for both mobile and desktop.
    </functionality>
    <user_experience>
      The app looks and feels exactly the same. All animations, transitions, and gesture interactions are visually indistinguishable from the current version. No user-facing changes.
    </user_experience>
    <code_quality>
      Zero duplicated logic across the codebase. All gesture handling follows one unified pattern through GestureUtils.ts. All animations use react-spring (motion and auto-animate removed). Hooks are readable and follow consistent patterns. Pure helper functions live at module level. Constants defined once at module scope. Team members can follow any code path by recognizing the established patterns.
    </code_quality>
    <technical_debt>
      Two unused dependencies removed (motion, @formkit/auto-animate). No manual requestAnimationFrame animation loops. No inline gesture threshold values. No duplicated parsing/formatting utilities across note hooks. useNavigation.ts has deduplicated callbacks and clean state management.
    </technical_debt>
  </success_criteria>
</project_specification>
